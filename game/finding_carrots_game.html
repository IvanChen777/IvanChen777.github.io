<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finding Carrots</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- D3.js library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Animation enhancement script -->
    <script src="finding_carrots_game.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            background-color: white;
            padding: 0 40px;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .visualization-container {
            width: 800px;
            height: 500px;
            margin: 0 auto;
            position: relative;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            overflow: hidden;
        }
        svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .road {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .intersection {
            fill: #555;
        }
        .trajectory {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-opacity: 0.85;
        }
        .trajectory-point {
            fill: #fff;
            stroke-width: 1.5;
        }
        .object-label {
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px white;
        }
        .legend {
            display: flex;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px 5px 10px;
            position: relative;
            z-index: 5;
        }
        .color-box {
            width: 20px;
            height: 10px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .legend-icon {
            margin-right: 5px;
            display: inline-block;
            flex-shrink: 0;
            vertical-align: middle;
        }
        .legend span {
            margin-left: 5px;
            font-size: 14px;
            font-weight: 500;
            display: inline-block;
            vertical-align: middle;
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            position: relative;
            z-index: 100;
        }
        .control-group {
            margin: 0 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            position: relative;
            z-index: 100;
        }
        button:hover {
            background-color: #2980b9;
        }
        .description {
            max-width: 800px;
            margin: 25px auto;
            line-height: 1.6;
            text-align: justify;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        .debug-console {
            display: none;
            margin: 20px auto;
            max-width: 800px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
        }
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-weight: bold;
            font-size: 18px;
            color: #2c3e50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #road-following-stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            padding: 8px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            color: #2c3e50;
            z-index: 100;
        }
        
        #road-size-value {
            display: inline-block;
            width: 30px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Finding Carrots!</h1>
    
    <div class="controls">
        <div class="control-group">
            <label for="object-count">Number of Rabbits:</label>
            <input type="number" id="object-count" min="1" max="10" value="5" style="width: 60px;">
            
            <label for="vehicle-count">Number of Vehicles:</label>
            <input type="number" id="vehicle-count" min="0" max="5" value="5" style="width: 60px;">
            
            <label for="parking-count">Number of Parking Spaces:</label>
            <input type="number" id="parking-count" min="0" max="5" value="5" style="width: 60px;">
        </div>
        <div class="control-group">
            <button id="update-btn">Update</button>
            <button id="play-btn">Play Animation</button>
            <button id="reset-btn">Reset</button>
        </div>
        <div class="control-group">
            <label for="layout-selector">Road Layout:</label>
            <select id="layout-selector">
                <option value="0">Grid Layout</option>
                <option value="1">Radial Layout</option>
                <option value="2">Organic Layout</option>
            </select>
        </div>
        <div class="control-group">
            <label for="road-size">Road Size:</label>
            <input type="number" id="road-size" min="0.5" max="2.0" step="0.1" value="1.0" style="width: 60px;">
            <button id="apply-size-btn">Apply Size</button>
        </div>
    </div>
    
    <div class="visualization-container">
        <svg id="visualization"></svg>
        <div id="completion-message"></div>
        <div id="road-following-stats" style="display: none;">
            <strong>Road Following:</strong> <span id="road-following-count">0/0</span> objects (<span id="road-following-percentage">0.0%</span>)
        </div>
    </div>
    
    <div class="legend" id="legend"></div>
    
    <div class="debug-console">
        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <h4 style="margin: 0;">Debug Console</h4>
            <label><input type="checkbox" id="debug-toggle"> Show Debug Info</label>
        </div>
        <div id="debug-info" style="max-height: 150px; overflow-y: auto;"></div>
    </div>
    
    <div class="description">
        <h3>Game Explanation</h3>
        <p>Welcome to Finding Carrots! Help the rabbits find their way to the carrots:</p>
        <ul>
            <li><strong>Number of Rabbits:</strong> Choose how many hungry rabbits will search for carrots (1-10)</li>
            <li><strong>Play Animation:</strong> Start the rabbits' journey to find their carrots</li>
            <li><strong>Reset:</strong> Return all rabbits to their starting positions</li>
            <li><strong>Road Layout:</strong> Change the pattern of roads the rabbits will follow</li>
            <li><strong>Road Size:</strong> Adjust how wide the roads are for the rabbits to travel on</li>
            <li><strong>Apply Size:</strong> Update the road width after changing the size slider</li>
        </ul>
    </div>

    <script>
        // Configuration
        const config = {
            width: 800,
            height: 500,
            margin: { top: 50, right: 50, bottom: 50, left: 50 },
            animationDuration: 20000, // 20 seconds for slower, more user-friendly motion
            objectColors: [
                "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
                "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
                "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5",
                "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5",
                "#b2df8a", "#fb9a99"
            ],
            roadColors: {
                primary: "#333",
                secondary: "#666",
                tertiary: "#999"
            },
            roadFollowingThreshold: 15 // Distance in pixels to consider a point near a road
        };

        // Road network layouts
        const roadLayouts = [
            // Layout 1: Grid
            {
                name: "Grid Layout",
                // Primary roads (main arteries)
                primaryRoads: [
                    { x1: 50, y1: 50, x2: 750, y2: 50 },    // Horizontal top
                    { x1: 50, y1: 450, x2: 750, y2: 450 },  // Horizontal bottom
                    { x1: 50, y1: 50, x2: 50, y2: 450 },    // Vertical left
                    { x1: 750, y1: 50, x2: 750, y2: 450 }   // Vertical right
                ],
                // Secondary roads (medium streets)
                secondaryRoads: [
                    { x1: 50, y1: 250, x2: 750, y2: 250 },   // Horizontal middle
                    { x1: 400, y1: 50, x2: 400, y2: 450 },   // Vertical middle
                    { x1: 200, y1: 50, x2: 200, y2: 450 },   // Vertical quarter
                    { x1: 600, y1: 50, x2: 600, y2: 450 }    // Vertical three-quarter
                ],
                // Tertiary roads (smaller streets)
                tertiaryRoads: [
                    { x1: 50, y1: 150, x2: 750, y2: 150 },   // Horizontal quarter
                    { x1: 50, y1: 350, x2: 750, y2: 350 },   // Horizontal three-quarter
                    { x1: 125, y1: 50, x2: 125, y2: 450 },   // Vertical 1/8
                    { x1: 275, y1: 50, x2: 275, y2: 450 },   // Vertical 3/8
                    { x1: 525, y1: 50, x2: 525, y2: 450 },   // Vertical 5/8
                    { x1: 675, y1: 50, x2: 675, y2: 450 }    // Vertical 7/8
                ],
                // Intersections
                intersections: [
                    // Major intersections (at primary road crossings)
                    { x: 50, y: 50, r: 8 },     // Top-left
                    { x: 400, y: 50, r: 8 },    // Top-middle
                    { x: 750, y: 50, r: 8 },    // Top-right
                    { x: 50, y: 250, r: 8 },    // Middle-left
                    { x: 400, y: 250, r: 8 },   // Center
                    { x: 750, y: 250, r: 8 },   // Middle-right
                    { x: 50, y: 450, r: 8 },    // Bottom-left
                    { x: 400, y: 450, r: 8 },   // Bottom-middle
                    { x: 750, y: 450, r: 8 },   // Bottom-right
                    
                    // Secondary intersections
                    { x: 200, y: 50, r: 6 },    // Secondary intersections
                    { x: 600, y: 50, r: 6 },
                    { x: 200, y: 250, r: 6 },
                    { x: 600, y: 250, r: 6 },
                    { x: 200, y: 450, r: 6 },
                    { x: 600, y: 450, r: 6 },
                    { x: 50, y: 150, r: 6 },
                    { x: 400, y: 150, r: 6 },
                    { x: 750, y: 150, r: 6 },
                    { x: 50, y: 350, r: 6 },
                    { x: 400, y: 350, r: 6 },
                    { x: 750, y: 350, r: 6 },
                    
                    // Tertiary intersections
                    { x: 125, y: 50, r: 5 },   // Various minor intersections
                    { x: 275, y: 50, r: 5 },
                    { x: 525, y: 50, r: 5 },
                    { x: 675, y: 50, r: 5 },
                    { x: 125, y: 150, r: 5 },
                    { x: 275, y: 150, r: 5 },
                    { x: 525, y: 150, r: 5 },
                    { x: 675, y: 150, r: 5 },
                    { x: 125, y: 250, r: 5 },
                    { x: 275, y: 250, r: 5 },
                    { x: 525, y: 250, r: 5 },
                    { x: 675, y: 250, r: 5 },
                    { x: 125, y: 350, r: 5 },
                    { x: 275, y: 350, r: 5 },
                    { x: 525, y: 350, r: 5 },
                    { x: 675, y: 350, r: 5 },
                    { x: 125, y: 450, r: 5 },
                    { x: 275, y: 450, r: 5 },
                    { x: 525, y: 450, r: 5 },
                    { x: 675, y: 450, r: 5 }
                ]
            },
            // Layout 2: Radial
            {
                name: "Radial Layout",
                primaryRoads: [
                    // Outer ring
                    { x1: 400, y1: 50, x2: 700, y2: 250 },
                    { x1: 700, y1: 250, x2: 400, y2: 450 },
                    { x1: 400, y1: 450, x2: 100, y2: 250 },
                    { x1: 100, y1: 250, x2: 400, y2: 50 }
                ],
                secondaryRoads: [
                    // Inner ring
                    { x1: 400, y1: 150, x2: 550, y2: 250 },
                    { x1: 550, y1: 250, x2: 400, y2: 350 },
                    { x1: 400, y1: 350, x2: 250, y2: 250 },
                    { x1: 250, y1: 250, x2: 400, y2: 150 },
                    // Spokes
                    { x1: 400, y1: 50, x2: 400, y2: 450 },
                    { x1: 100, y1: 250, x2: 700, y2: 250 }
                ],
                tertiaryRoads: [
                    // Diagonal spokes
                    { x1: 175, y1: 125, x2: 625, y2: 375 },
                    { x1: 175, y1: 375, x2: 625, y2: 125 }
                ],
                intersections: [
                    // Center
                    { x: 400, y: 250, r: 8 },
                    // Main compass points
                    { x: 400, y: 50, r: 7 },
                    { x: 700, y: 250, r: 7 },
                    { x: 400, y: 450, r: 7 },
                    { x: 100, y: 250, r: 7 },
                    // Inner ring intersections
                    { x: 400, y: 150, r: 6 },
                    { x: 550, y: 250, r: 6 },
                    { x: 400, y: 350, r: 6 },
                    { x: 250, y: 250, r: 6 },
                    // Diagonal intersections
                    { x: 175, y: 125, r: 5 },
                    { x: 625, y: 375, r: 5 },
                    { x: 175, y: 375, r: 5 },
                    { x: 625, y: 125, r: 5 },
                    // Other intersections
                    { x: 325, y: 175, r: 4 },
                    { x: 475, y: 175, r: 4 },
                    { x: 325, y: 325, r: 4 },
                    { x: 475, y: 325, r: 4 }
                ]
            },
            // Layout 3: Organic
            {
                name: "Organic Layout",
                primaryRoads: [
                    // Main curved road
                    { x1: 50, y1: 250, x2: 200, y2: 150 },
                    { x1: 200, y1: 150, x2: 400, y2: 200 },
                    { x1: 400, y1: 200, x2: 600, y2: 300 },
                    { x1: 600, y1: 300, x2: 750, y2: 250 },
                    // Secondary main road
                    { x1: 200, y1: 400, x2: 400, y2: 350 },
                    { x1: 400, y1: 350, x2: 600, y2: 400 }
                ],
                secondaryRoads: [
                    // Connecting roads
                    { x1: 200, y1: 150, x2: 150, y2: 50 },
                    { x1: 400, y1: 200, x2: 400, y2: 50 },
                    { x1: 600, y1: 300, x2: 650, y2: 150 },
                    { x1: 200, y1: 400, x2: 150, y2: 450 },
                    { x1: 400, y1: 350, x2: 400, y2: 450 },
                    { x1: 600, y1: 400, x2: 650, y2: 450 },
                    // Cross connections
                    { x1: 300, y1: 175, x2: 300, y2: 375 },
                    { x1: 500, y1: 250, x2: 500, y2: 400 }
                ],
                tertiaryRoads: [
                    // Small local roads
                    { x1: 100, y1: 150, x2: 150, y2: 200 },
                    { x1: 150, y1: 200, x2: 100, y2: 300 },
                    { x1: 100, y1: 300, x2: 150, y2: 350 },
                    { x1: 700, y1: 200, x2: 650, y2: 250 },
                    { x1: 650, y1: 250, x2: 700, y2: 350 },
                    { x1: 700, y1: 350, x2: 650, y2: 400 },
                    { x1: 250, y1: 100, x2: 350, y2: 150 },
                    { x1: 450, y1: 150, x2: 550, y2: 100 },
                    { x1: 250, y1: 400, x2: 350, y2: 450 },
                    { x1: 450, y1: 450, x2: 550, y2: 400 }
                ],
                intersections: [
                    // Primary intersections
                    { x: 200, y: 150, r: 7 },
                    { x: 400, y: 200, r: 7 },
                    { x: 600, y: 300, r: 7 },
                    { x: 200, y: 400, r: 7 },
                    { x: 400, y: 350, r: 7 },
                    { x: 600, y: 400, r: 7 },
                    // Secondary intersections
                    { x: 150, y: 50, r: 5 },
                    { x: 400, y: 50, r: 5 },
                    { x: 650, y: 150, r: 5 },
                    { x: 150, y: 450, r: 5 },
                    { x: 400, y: 450, r: 5 },
                    { x: 650, y: 450, r: 5 },
                    { x: 300, y: 175, r: 5 },
                    { x: 300, y: 375, r: 5 },
                    { x: 500, y: 250, r: 5 },
                    { x: 500, y: 400, r: 5 },
                    // Tertiary intersections
                    { x: 100, y: 150, r: 4 },
                    { x: 150, y: 200, r: 4 },
                    { x: 100, y: 300, r: 4 },
                    { x: 150, y: 350, r: 4 },
                    { x: 700, y: 200, r: 4 },
                    { x: 650, y: 250, r: 4 },
                    { x: 700, y: 350, r: 4 },
                    { x: 650, y: 400, r: 4 },
                    { x: 250, y: 100, r: 4 },
                    { x: 350, y: 150, r: 4 },
                    { x: 450, y: 150, r: 4 },
                    { x: 550, y: 100, r: 4 },
                    { x: 250, y: 400, r: 4 },
                    { x: 350, y: 450, r: 4 },
                    { x: 450, y: 450, r: 4 },
                    { x: 550, y: 400, r: 4 }
                ]
            }
        ];

        // Global variables
        let currentTrajectoryData = [];
        let currentVehicleData = [];
        let currentRoadLayout = 0;
        let roadNetwork = roadLayouts[0]; // Initialize with first layout
        let roadMapScale = 1.0;
        let riverSegments = [];
        let roadFollowingStats = { total: 0, following: 0, percentage: 0 };
        let animationId = null;
        let animationStartTime = null;
        
        // Helper function to calculate distance from a point to a line segment
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            
            if (len_sq !== 0) { // in case of 0 length line
                param = dot / len_sq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Helper function to project a point onto a line segment and return the parameter t
        // where t=0 is the start point and t=1 is the end point
        function projectPointOnLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            let param = -1;
            
            if (len_sq !== 0) {
                param = dot / len_sq;
            }
            
            // Clamp parameter to [0,1] for line segment
            return Math.max(0, Math.min(1, param));
        }
        
        // Check if a point is near any road segment
        function isPointNearRoad(x, y) {
            const threshold = 15 * roadMapScale; // Adjust threshold based on road scale
            
            // Check primary roads
            for (const road of roadNetwork.primaryRoads) {
                if (distanceToLineSegment(x, y, road.x1, road.y1, road.x2, road.y2) < threshold) {
                    return true;
                }
            }
            
            // Check secondary roads
            for (const road of roadNetwork.secondaryRoads) {
                if (distanceToLineSegment(x, y, road.x1, road.y1, road.x2, road.y2) < threshold) {
                    return true;
                }
            }
            
            // Check tertiary roads
            for (const road of roadNetwork.tertiaryRoads) {
                if (distanceToLineSegment(x, y, road.x1, road.y1, road.x2, road.y2) < threshold) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Calculate road following statistics
        function calculateRoadFollowingStats() {
            if (currentTrajectoryData.length === 0) return;
            
            let totalFollowing = 0;
            
            for (const trajectory of currentTrajectoryData) {
                // Count points near road, giving more weight to middle points
                // This prevents trajectories that just cross roads from being counted as "following"
                let pointsNearRoad = 0;
                let totalPoints = trajectory.points.length;
                
                // Skip first and last point in calculation to focus on the path itself
                const pointsToCheck = totalPoints <= 3 ? trajectory.points : trajectory.points.slice(1, -1);
                const adjustedTotal = pointsToCheck.length;
                
                // Check each point
                for (const point of pointsToCheck) {
                    if (isPointNearRoad(point.x, point.y)) {
                        pointsNearRoad++;
                    }
                }
                
                // Calculate percentage based on middle points
                const followingPercentage = adjustedTotal > 0 ? 
                    (pointsNearRoad / adjustedTotal) * 100 : 0;
                
                // Consider an object to be "following the road" if at least 75% of its points are near roads
                // Higher threshold for more accuracy
                if (followingPercentage >= 75) {
                    totalFollowing++;
                    trajectory.isFollowingRoad = true;
                } else {
                    trajectory.isFollowingRoad = false;
                }
                
                // Store the following percentage on the trajectory object
                trajectory.followingPercentage = followingPercentage;
            }
            
            // Update the stats display
            const followingPercentage = currentTrajectoryData.length > 0 ?
                (totalFollowing / currentTrajectoryData.length) * 100 : 0;
            
            document.getElementById('road-following-percentage').textContent = 
                `${followingPercentage.toFixed(1)}%`;
            document.getElementById('road-following-count').textContent = 
                `${totalFollowing} / ${currentTrajectoryData.length}`;
            
            debugLog("Calculated road following stats", { 
                following: totalFollowing, 
                total: currentTrajectoryData.length,
                percentage: followingPercentage
            });
        }
        
        // Debug logging function
        function debugLog(message, data = null) {
            const debugToggle = document.getElementById('debug-toggle');
            if (debugToggle && debugToggle.checked) {
                const debugInfo = document.getElementById('debug-info');
                const timestamp = new Date().toLocaleTimeString();
                const logItem = document.createElement('div');
                logItem.innerHTML = `<span style="color:#888">[${timestamp}]</span> ${message}`;
                if (data) {
                    logItem.innerHTML += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                }
                debugInfo.appendChild(logItem);
                debugInfo.scrollTop = debugInfo.scrollHeight;
                console.log(message, data || '');
            }
        }
        
        // Store river locations for collision detection
        // riverSegments already declared above
        
        // Cache for safe carrot positions to prevent movement during animation
        let safeCarrotPositions = {};
        
        // Function to check if a point is in a river
        function isPointInRiver(x, y) {
            for (const river of riverSegments) {
                // Calculate distance from point to line segment (river)
                const dx = river.x2 - river.x1;
                const dy = river.y2 - river.y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize direction vector
                const dirX = dx / length;
                const dirY = dy / length;
                
                // Vector from line start to point
                const vx = x - river.x1;
                const vy = y - river.y1;
                
                // Project point onto line
                const dot = vx * dirX + vy * dirY;
                
                // Get closest point on line segment
                let closestX, closestY;
                
                if (dot < 0) {
                    // Point is before start of line
                    closestX = river.x1;
                    closestY = river.y1;
                } else if (dot > length) {
                    // Point is after end of line
                    closestX = river.x2;
                    closestY = river.y2;
                } else {
                    // Point is within line segment
                    closestX = river.x1 + dirX * dot;
                    closestY = river.y1 + dirY * dot;
                }
                
                // Calculate distance from point to closest point on line
                const distance = Math.sqrt(
                    Math.pow(x - closestX, 2) + 
                    Math.pow(y - closestY, 2)
                );
                
                // Check if point is within river width
                if (distance < river.width / 2) {
                    return true;
                }
            }
            return false;
        }
        
        // Function to find a safe position for carrot (not in river)
        function findSafeCarrotPosition(endPoint, trajectoryId) {
            // Check if we already have a cached safe position for this trajectory
            const cacheKey = `${trajectoryId}-${endPoint.x.toFixed(2)}-${endPoint.y.toFixed(2)}`;
            if (safeCarrotPositions[cacheKey]) {
                return safeCarrotPositions[cacheKey];
            }
            
            // Try the original position first
            if (!isPointInRiver(endPoint.x, endPoint.y)) {
                // Cache this position
                safeCarrotPositions[cacheKey] = endPoint;
                return endPoint;
            }
            
            // If original position is in a river, try positions around it
            const searchRadius = 30;
            const attempts = 20;
            
            for (let i = 0; i < attempts; i++) {
                // Try random positions within search radius
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * searchRadius;
                const newX = endPoint.x + Math.cos(angle) * distance;
                const newY = endPoint.y + Math.sin(angle) * distance;
                
                // Check if this position is safe
                if (!isPointInRiver(newX, newY)) {
                    const safePosition = { x: newX, y: newY };
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    const legendIcon = document.createElement('i');
                    legendIcon.className = 'fas fa-carrot legend-icon';
                    legendIcon.style.color = 'orange';
                    const legendText = document.createElement('span');
                    legendText.textContent = 'Carrot (Destination)';
                    legendItem.appendChild(legendIcon);
                    legendItem.appendChild(legendText);
                    document.getElementById('legend').appendChild(legendItem);
                    
                    const vehicleLegendItem = document.createElement('div');
                    vehicleLegendItem.className = 'legend-item';
                    const vehicleLegendIcon = document.createElement('svg');
                    vehicleLegendIcon.width = 20;
                    vehicleLegendIcon.height = 12;
                    vehicleLegendIcon.className = 'legend-icon';
                    const vehicleBody = document.createElement('rect');
                    vehicleBody.x = 2;
                    vehicleBody.y = 2;
                    vehicleBody.width = 16;
                    vehicleBody.height = 8;
                    vehicleBody.rx = 2;
                    vehicleBody.ry = 2;
                    vehicleBody.fill = '#1f77b4';
                    vehicleBody.stroke = 'white';
                    vehicleBody.strokeWidth = 1;
                    const vehicleWindow1 = document.createElement('rect');
                    vehicleWindow1.x = 4;
                    vehicleWindow1.y = 3;
                    vehicleWindow1.width = 4;
                    vehicleWindow1.height = 3;
                    vehicleWindow1.rx = 1;
                    vehicleWindow1.fill = '#87CEEB';
                    vehicleWindow1.opacity = 0.8;
                    const vehicleWindow2 = document.createElement('rect');
                    vehicleWindow2.x = 12;
                    vehicleWindow2.y = 3;
                    vehicleWindow2.width = 4;
                    vehicleWindow2.height = 3;
                    vehicleWindow2.rx = 1;
                    vehicleWindow2.fill = '#87CEEB';
                    vehicleWindow2.opacity = 0.8;
                    const vehicleWheel1 = document.createElement('circle');
                    vehicleWheel1.cx = 5;
                    vehicleWheel1.cy = 10;
                    vehicleWheel1.r = 1;
                    vehicleWheel1.fill = '#333';
                    const vehicleWheel2 = document.createElement('circle');
                    vehicleWheel2.cx = 15;
                    vehicleWheel2.cy = 10;
                    vehicleWheel2.r = 1;
                    vehicleWheel2.fill = '#333';
                    vehicleLegendIcon.appendChild(vehicleBody);
                    vehicleLegendIcon.appendChild(vehicleWindow1);
                    vehicleLegendIcon.appendChild(vehicleWindow2);
                    vehicleLegendIcon.appendChild(vehicleWheel1);
                    vehicleLegendIcon.appendChild(vehicleWheel2);
                    const vehicleLegendText = document.createElement('span');
                    vehicleLegendText.textContent = 'Vehicle (Road Follower)';
                    vehicleLegendItem.appendChild(vehicleLegendIcon);
                    vehicleLegendItem.appendChild(vehicleLegendText);
                    document.getElementById('legend').appendChild(vehicleLegendItem);
                    
                    // Cache this position
                    safeCarrotPositions[cacheKey] = safePosition;
                    return safePosition;
                }
            }
            
            // If all attempts fail, move the carrot further away from the river
            const angle = Math.random() * Math.PI * 2;
            const safePosition = {
                x: endPoint.x + Math.cos(angle) * (searchRadius + 20),
                y: endPoint.y + Math.sin(angle) * (searchRadius + 20)
            };
            
            // Cache this position
            safeCarrotPositions[cacheKey] = safePosition;
            return safePosition;
        }
        
        // Generate trajectory data
        function generateTrajectories() {
            const objectCount = parseInt(document.getElementById('object-count').value) || 5;
            debugLog("generateTrajectories called", { objectCount });
            currentTrajectoryData = [];
            
            for (let i = 0; i < objectCount; i++) {
                const id = `Rabbit ${i + 1}`;
                const color = config.objectColors[i % config.objectColors.length];
                const points = [];
                
                // Generate start and end points near intersections or roads
                let startPoint, endPoint;
                
                // 80% chance to start at or near an intersection
                if (Math.random() < 0.8) {
                    const intersections = roadNetwork.intersections;
                    const randomIntersection = intersections[Math.floor(Math.random() * intersections.length)];
                    // Add small random offset for realism
                    startPoint = { 
                        x: randomIntersection.x + (Math.random() - 0.5) * 15, 
                        y: randomIntersection.y + (Math.random() - 0.5) * 15 
                    };
                } else {
                    // Random point near a road
                    const allRoads = [
                        ...roadNetwork.primaryRoads,
                        ...roadNetwork.secondaryRoads
                    ];
                    const randomRoad = allRoads[Math.floor(Math.random() * allRoads.length)];
                    const t = Math.random();
                    startPoint = {
                        x: randomRoad.x1 + (randomRoad.x2 - randomRoad.x1) * t + (Math.random() - 0.5) * 20,
                        y: randomRoad.y1 + (randomRoad.y2 - randomRoad.y1) * t + (Math.random() - 0.5) * 20
                    };
                }
                
                // 80% chance to end at or near an intersection
                if (Math.random() < 0.8) {
                    const intersections = roadNetwork.intersections;
                    // Choose a different intersection than the start if possible
                    let attempts = 0;
                    let randomIntersection;
                    do {
                        randomIntersection = intersections[Math.floor(Math.random() * intersections.length)];
                        attempts++;
                    } while (attempts < 3 && 
                           Math.abs(randomIntersection.x - startPoint.x) < 100 && 
                           Math.abs(randomIntersection.y - startPoint.y) < 100);
                    
                    endPoint = { 
                        x: randomIntersection.x + (Math.random() - 0.5) * 15, 
                        y: randomIntersection.y + (Math.random() - 0.5) * 15 
                    };
                } else {
                    // Random point near a road but away from start
                    const allRoads = [
                        ...roadNetwork.primaryRoads,
                        ...roadNetwork.secondaryRoads
                    ];
                    let randomRoad;
                    let attempts = 0;
                    let candidatePoint;
                    
                    do {
                        randomRoad = allRoads[Math.floor(Math.random() * allRoads.length)];
                        const t = Math.random();
                        candidatePoint = {
                            x: randomRoad.x1 + (randomRoad.x2 - randomRoad.x1) * t + (Math.random() - 0.5) * 20,
                            y: randomRoad.y1 + (randomRoad.y2 - randomRoad.y1) * t + (Math.random() - 0.5) * 20
                        };
                        attempts++;
                    } while (attempts < 3 && 
                           Math.sqrt(Math.pow(candidatePoint.x - startPoint.x, 2) + 
                                    Math.pow(candidatePoint.y - startPoint.y, 2)) < 150);
                    
                    endPoint = candidatePoint;
                }
                
                // Add start point
                points.push(startPoint);
                
                // Generate path with realistic movement along roads
                // 90% chance to follow roads for realism
                const followRoads = Math.random() < 0.9;
                
                if (followRoads) {
                    // Find path through road network that strictly follows road edges
                    const allRoads = [
                        ...roadNetwork.primaryRoads,
                        ...roadNetwork.secondaryRoads,
                        ...roadNetwork.tertiaryRoads
                    ];
                    
                    // Find nearest road to start point
                    let startRoad = null;
                    let startRoadPoint = null;
                    let minStartDist = Infinity;
                    
                    for (const road of allRoads) {
                        const dist = distanceToLineSegment(
                            startPoint.x, startPoint.y,
                            road.x1, road.y1, road.x2, road.y2
                        );
                        
                        if (dist < minStartDist) {
                            minStartDist = dist;
                            startRoad = road;
                            
                            // Calculate closest point on the road
                            const t = projectPointOnLineSegment(
                                startPoint.x, startPoint.y,
                                road.x1, road.y1, road.x2, road.y2
                            );
                            
                            startRoadPoint = {
                                x: road.x1 + t * (road.x2 - road.x1),
                                y: road.y1 + t * (road.y2 - road.y1)
                            };
                        }
                    }
                    
                    // Find nearest road to end point
                    let endRoad = null;
                    let endRoadPoint = null;
                    let minEndDist = Infinity;
                    
                    for (const road of allRoads) {
                        const dist = distanceToLineSegment(
                            endPoint.x, endPoint.y,
                            road.x1, road.y1, road.x2, road.y2
                        );
                        
                        if (dist < minEndDist) {
                            minEndDist = dist;
                            endRoad = road;
                            
                            // Calculate closest point on the road
                            const t = projectPointOnLineSegment(
                                endPoint.x, endPoint.y,
                                road.x1, road.y1, road.x2, road.y2
                            );
                            
                            endRoadPoint = {
                                x: road.x1 + t * (road.x2 - road.x1),
                                y: road.y1 + t * (road.y2 - road.y1)
                            };
                        }
                    }
                    
                    // Start with the actual point on the road
                    if (startRoadPoint) {
                        // Replace the start point with the point on the road
                        points[0] = startRoadPoint;
                    }
                    
                    // Build a path through the road network
                    const roadPath = [];
                    
                    // Find intersections connected to the start road
                    const startIntersections = [];
                    for (const intersection of roadNetwork.intersections) {
                        // Check if intersection is on the start road
                        const distToRoad = distanceToLineSegment(
                            intersection.x, intersection.y,
                            startRoad.x1, startRoad.y1, startRoad.x2, startRoad.y2
                        );
                        
                        if (distToRoad < 5) { // If intersection is on this road
                            startIntersections.push(intersection);
                        }
                    }
                    
                    // Find intersections connected to the end road
                    const endIntersections = [];
                    for (const intersection of roadNetwork.intersections) {
                        // Check if intersection is on the end road
                        const distToRoad = distanceToLineSegment(
                            intersection.x, intersection.y,
                            endRoad.x1, endRoad.y1, endRoad.x2, endRoad.y2
                        );
                        
                        if (distToRoad < 5) { // If intersection is on this road
                            endIntersections.push(intersection);
                        }
                    }
                    
                    // Add points along the start road to the nearest intersection
                    if (startIntersections.length > 0) {
                        // Find closest intersection to the start point
                        let closestIntersection = startIntersections[0];
                        let minDist = Math.sqrt(
                            Math.pow(startRoadPoint.x - closestIntersection.x, 2) + 
                            Math.pow(startRoadPoint.y - closestIntersection.y, 2)
                        );
                        
                        for (let i = 1; i < startIntersections.length; i++) {
                            const dist = Math.sqrt(
                                Math.pow(startRoadPoint.x - startIntersections[i].x, 2) + 
                                Math.pow(startRoadPoint.y - startIntersections[i].y, 2)
                            );
                            
                            if (dist < minDist) {
                                minDist = dist;
                                closestIntersection = startIntersections[i];
                            }
                        }
                        
                        // Add points along the road to the intersection
                        const numPoints = Math.floor(Math.random() * 2) + 3; // 3-4 points
                        for (let j = 1; j <= numPoints; j++) {
                            const t = j / (numPoints + 1);
                            const point = {
                                x: startRoadPoint.x + (closestIntersection.x - startRoadPoint.x) * t + (Math.random() - 0.5) * 3,
                                y: startRoadPoint.y + (closestIntersection.y - startRoadPoint.y) * t + (Math.random() - 0.5) * 3
                            };
                            points.push(point);
                        }
                        
                        // Add the intersection
                        points.push({
                            x: closestIntersection.x,
                            y: closestIntersection.y
                        });
                        
                        // Now find a path through other roads
                        // Add 1-3 random intersections that are connected by roads
                        const numIntermediateIntersections = Math.floor(Math.random() * 3) + 1;
                        let currentIntersection = closestIntersection;
                        
                        for (let j = 0; j < numIntermediateIntersections; j++) {
                            // Find roads connected to current intersection
                            const connectedRoads = [];
                            
                            for (const road of allRoads) {
                                const distToStart = Math.sqrt(
                                    Math.pow(currentIntersection.x - road.x1, 2) + 
                                    Math.pow(currentIntersection.y - road.y1, 2)
                                );
                                
                                const distToEnd = Math.sqrt(
                                    Math.pow(currentIntersection.x - road.x2, 2) + 
                                    Math.pow(currentIntersection.y - road.y2, 2)
                                );
                                
                                if (distToStart < 5 || distToEnd < 5) {
                                    connectedRoads.push(road);
                                }
                            }
                            
                            if (connectedRoads.length > 0) {
                                // Pick a random connected road
                                const nextRoad = connectedRoads[Math.floor(Math.random() * connectedRoads.length)];
                                
                                // Find the other end of the road (not the current intersection)
                                const distToStart = Math.sqrt(
                                    Math.pow(currentIntersection.x - nextRoad.x1, 2) + 
                                    Math.pow(currentIntersection.y - nextRoad.y1, 2)
                                );
                                
                                const nextPoint = (distToStart < 5) ? 
                                    { x: nextRoad.x2, y: nextRoad.y2 } : 
                                    { x: nextRoad.x1, y: nextRoad.y1 };
                                
                                // Add points along this road
                                const numRoadPoints = Math.floor(Math.random() * 3) + 2; // 2-4 points
                                for (let k = 1; k <= numRoadPoints; k++) {
                                    const t = k / (numRoadPoints + 1);
                                    const point = {
                                        x: currentIntersection.x + (nextPoint.x - currentIntersection.x) * t + (Math.random() - 0.5) * 3,
                                        y: currentIntersection.y + (nextPoint.y - currentIntersection.y) * t + (Math.random() - 0.5) * 3
                                    };
                                    points.push(point);
                                }
                                
                                // Find if there's an intersection at the next point
                                let nextIntersection = null;
                                for (const intersection of roadNetwork.intersections) {
                                    const dist = Math.sqrt(
                                        Math.pow(nextPoint.x - intersection.x, 2) + 
                                        Math.pow(nextPoint.y - intersection.y, 2)
                                    );
                                    
                                    if (dist < 5) {
                                        nextIntersection = intersection;
                                        break;
                                    }
                                }
                                
                                if (nextIntersection) {
                                    points.push({
                                        x: nextIntersection.x,
                                        y: nextIntersection.y
                                    });
                                    currentIntersection = nextIntersection;
                                } else {
                                    // Just add the end of the road
                                    points.push(nextPoint);
                                    currentIntersection = { x: nextPoint.x, y: nextPoint.y };
                                }
                            }
                        }
                        
                        // Finally, add points to the end road
                        if (endRoadPoint) {
                            const numFinalPoints = Math.floor(Math.random() * 2) + 2; // 2-3 points
                            for (let j = 1; j <= numFinalPoints; j++) {
                                const t = j / (numFinalPoints + 1);
                                const point = {
                                    x: currentIntersection.x + (endRoadPoint.x - currentIntersection.x) * t + (Math.random() - 0.5) * 3,
                                    y: currentIntersection.y + (endRoadPoint.y - currentIntersection.y) * t + (Math.random() - 0.5) * 3
                                };
                                points.push(point);
                            }
                            
                            // Add the end road point
                            points.push(endRoadPoint);
                        }
                    }
                } else {
                    // Non-road following trajectory - smoother and more direct
                    // Calculate distance between start and end
                    const distance = Math.sqrt(
                        Math.pow(endPoint.x - startPoint.x, 2) + 
                        Math.pow(endPoint.y - startPoint.y, 2)
                    );
                    
                    // More points for longer distances
                    const numPoints = Math.max(3, Math.min(8, Math.floor(distance / 80)));
                    
                    for (let j = 1; j < numPoints; j++) {
                        const t = j / numPoints;
                        
                        // Curved path with controlled randomness
                        // Add some curvature with a sine wave
                        const curveFactor = (Math.random() * 0.4) + 0.1; // 0.1 to 0.5
                        const curveOffset = Math.sin(t * Math.PI) * distance * curveFactor;
                        
                        // Calculate perpendicular direction to create curve
                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        
                        // Perpendicular vector
                        let perpX = -dy / length;
                        let perpY = dx / length;
                        
                        // Randomly flip direction of curve
                        if (Math.random() < 0.5) {
                            perpX = -perpX;
                            perpY = -perpY;
                        }
                        
                        // Linear interpolation with curve
                        const x = startPoint.x + dx * t + perpX * curveOffset;
                        const y = startPoint.y + dy * t + perpY * curveOffset;
                        
                        points.push({ x, y });
                    }
                }
                
                // Add end point
                points.push(endPoint);
                
                // Add timing for more realistic staggered animation
                // Objects start at different times but with more consistent speeds
                const startTime = Math.random() * 0.2; // Start within first 20% of animation
                
                // Duration based on path length for more realistic speed
                let pathLength = 0;
                for (let j = 1; j < points.length; j++) {
                    pathLength += Math.sqrt(
                        Math.pow(points[j].x - points[j-1].x, 2) + 
                        Math.pow(points[j].y - points[j-1].y, 2)
                    );
                }
                
                // Normalize path length to get consistent speed across trajectories
                // Longer paths take more time proportionally
                const baseSpeed = 0.15; // pixels per millisecond
                const duration = Math.min(0.8, pathLength / (config.width * baseSpeed));
                const endTime = Math.min(1.0, startTime + duration);
                
                currentTrajectoryData.push({
                    id,
                    color,
                    points,
                    startTime,
                    endTime
                });
            }
            
            debugLog("Generated trajectories", { count: currentTrajectoryData.length, stats: roadFollowingStats });
        }
        
        // Generate vehicle paths that strictly follow roads
        function generateVehicles() {
            const vehicleCount = parseInt(document.getElementById("vehicle-count").value) || 3;
            debugLog("generateVehicles called", { vehicleCount });
            currentVehicleData = [];
            
            const roadNetwork = roadLayouts[currentRoadLayout];
            const parkingSpaces = createParkingSpaces(roadNetwork.intersections);
            
            // Only generate vehicles if there are at least 2 parking spaces
            const actualVehicleCount = parkingSpaces.length >= 2 ? vehicleCount : 0;
            
            debugLog("Generating vehicles", { 
                vehicleCount,
                actualVehicleCount,
                parkingSpaceCount: parkingSpaces.length
            });
            
            if (actualVehicleCount === 0) return;
            
            for (let i = 0; i < actualVehicleCount; i++) {
                const id = `Vehicle ${i + 1}`;
                
                // Select random start and end parking spaces
                const startParkingSpace = parkingSpaces[Math.floor(Math.random() * parkingSpaces.length)];
                let endParkingSpace;
                do {
                    endParkingSpace = parkingSpaces[Math.floor(Math.random() * parkingSpaces.length)];
                } while (endParkingSpace === startParkingSpace && parkingSpaces.length > 1);
                
                // Generate path from parking space to parking space
                const finalVehiclePath = generateParkingSpacePath(startParkingSpace, endParkingSpace, roadNetwork);
                
                debugLog("Created parking-to-parking vehicle path", { 
                    vehicleId: id,
                    pathLength: finalVehiclePath.length,
                    startParking: `P${startParkingSpace.id} (${startParkingSpace.x},${startParkingSpace.y})`,
                    endParking: `P${endParkingSpace.id} (${endParkingSpace.x},${endParkingSpace.y})`
                });
                
                if (finalVehiclePath.length > 0) { // Accept any valid path
                    // Calculate path distance to determine appropriate timing
                    const pathDistance = calculateTotalPathDistance(finalVehiclePath);
                    const averageSpeed = 150; // pixels per second (adjust for desired speed)
                    const travelDuration = Math.min(0.8, pathDistance / averageSpeed / 20); // 20 second animation
                    
                    const startTime = Math.random() * 0.1; // Very early start
                    const endTime = Math.min(0.95, startTime + travelDuration); // Ensure completion before animation ends
                    
                    currentVehicleData.push({
                        id: id,
                        color: config.objectColors[i % config.objectColors.length],
                        points: finalVehiclePath,
                        startTime: startTime,
                        endTime: endTime
                    });
                    
                    debugLog("Created vehicle", { 
                        vehicleId: id,
                        pathLength: finalVehiclePath.length,
                        duration: travelDuration,
                        startTime: startTime,
                        endTime: endTime
                    });
                }
            }
            
            debugLog("Generated vehicles", { count: currentVehicleData.length });
        }
        
        // Create predefined route templates that guarantee turning
        function createRouteTemplates(nodes, links, roadNetwork) {
            const templates = [];
            
            // Find boundary nodes (corners and edges)
            const boundaryNodes = [];
            for (const [nodeId, node] of nodes) {
                const connections = links.get(nodeId) || [];
                if (connections.length >= 2) { // Has multiple connections for turning
                    boundaryNodes.push(node);
                }
            }
            
            if (boundaryNodes.length >= 4) {
                // Create corner-to-corner diagonal routes
                const corners = findGridCorners(boundaryNodes, roadNetwork);
                
                if (corners.length >= 4) {
                    templates.push({
                        type: 'diagonal-top-left-to-bottom-right',
                        start: corners[0], // top-left
                        end: corners[2]    // bottom-right
                    });
                    
                    templates.push({
                        type: 'diagonal-top-right-to-bottom-left',
                        start: corners[1], // top-right
                        end: corners[3]    // bottom-left
                    });
                }
                
                // Create L-shaped routes that guarantee multiple turns
                templates.push({
                    type: 'L-shape-horizontal-first',
                    start: boundaryNodes[0],
                    end: boundaryNodes[Math.floor(boundaryNodes.length / 2)],
                    waypoints: [boundaryNodes[Math.floor(boundaryNodes.length / 4)]]
                });
                
                templates.push({
                    type: 'L-shape-vertical-first',
                    start: boundaryNodes[1],
                    end: boundaryNodes[Math.floor(boundaryNodes.length * 3 / 4)],
                    waypoints: [boundaryNodes[Math.floor(boundaryNodes.length / 3)]]
                });
            }
            
            return templates;
        }
        
        // Find corner nodes in a grid-like structure
        function findGridCorners(nodes, roadNetwork) {
            if (nodes.length < 4) return nodes;
            
            // Sort nodes to find corners (extreme positions)
            const sorted = [...nodes];
            sorted.sort((a, b) => a.x - b.x || a.y - b.y);
            
            const minX = Math.min(...nodes.map(n => n.x));
            const maxX = Math.max(...nodes.map(n => n.x));
            const minY = Math.min(...nodes.map(n => n.y));
            const maxY = Math.max(...nodes.map(n => n.y));
            
            const corners = [];
            
            // Find approximate corners
            for (const node of nodes) {
                const isLeftEdge = Math.abs(node.x - minX) < 20;
                const isRightEdge = Math.abs(node.x - maxX) < 20;
                const isTopEdge = Math.abs(node.y - minY) < 20;
                const isBottomEdge = Math.abs(node.y - maxY) < 20;
                
                if ((isLeftEdge && isTopEdge) || (isRightEdge && isTopEdge) || 
                    (isLeftEdge && isBottomEdge) || (isRightEdge && isBottomEdge)) {
                    corners.push(node);
                }
            }
            
            return corners.length >= 4 ? corners.slice(0, 4) : nodes.slice(0, 4);
        }
        
        // Generate path from a route template
        function generatePathFromTemplate(template, nodes, links) {
            if (!template.start || !template.end) return [];
            
            // Use Dijkstra to find path between template points
            const path = dijkstraPath(template.start, template.end, nodes, links);
            
            if (path.length > 0) {
                // Convert node path to coordinate path with smooth interpolation
                return convertNodePathToCoordinates(path, links);
            }
            
            return [];
        }
        
        // Find corner nodes for fallback method
        function findCornerNodes(nodes, roadNetwork) {
            const nodeArray = Array.from(nodes.values());
            return findGridCorners(nodeArray, roadNetwork);
        }
        
        // Generate path between two specific nodes
        function generatePathBetweenNodes(startNode, endNode, nodes, links) {
            const path = dijkstraPath(startNode, endNode, nodes, links);
            if (path.length > 0) {
                return convertNodePathToCoordinates(path, links);
            }
            return [];
        }
        
        // Convert node-based path to coordinate-based path
        function convertNodePathToCoordinates(nodePath, links) {
            if (nodePath.length < 2) return [];
            
            const coordinates = [];
            
            for (let i = 0; i < nodePath.length - 1; i++) {
                const currentNode = nodePath[i];
                const nextNode = nodePath[i + 1];
                
                // Add current node position
                coordinates.push({ x: currentNode.x, y: currentNode.y });
                
                // Add intermediate points for smooth turning
                if (i < nodePath.length - 2) {
                    const prevNode = i > 0 ? nodePath[i - 1] : currentNode;
                    const futureNode = nodePath[i + 2];
                    
                    // Calculate turning points for smooth curves
                    const turnRadius = 15;
                    const turningPoints = calculateTurningPoints(
                        prevNode, currentNode, nextNode, futureNode, turnRadius
                    );
                    
                    coordinates.push(...turningPoints);
                }
            }
            
            // Add final node
            coordinates.push({ 
                x: nodePath[nodePath.length - 1].x, 
                y: nodePath[nodePath.length - 1].y 
            });
            
            return coordinates;
        }
        
        // Generate grid-based path that follows road segments with 90-degree turns only
        function generateGridBasedPath(startRoad, endRoad, allRoads, intersections) {
            const path = [];
            
            // Start at beginning of start road
            const startPoint = { x: startRoad.x1, y: startRoad.y1 };
            const startEndPoint = { x: startRoad.x2, y: startRoad.y2 };
            
            // Target is beginning of end road
            const endPoint = { x: endRoad.x1, y: endRoad.y1 };
            
            path.push(startPoint);
            path.push(startEndPoint);
            
            // Find path from end of start road to beginning of end road using grid movement
            const gridPath = findGridPath(startEndPoint, endPoint, allRoads, intersections);
            path.push(...gridPath);
            
            // End at end of target road
            path.push({ x: endRoad.x2, y: endRoad.y2 });
            
            return path;
        }
        
        // Find path through grid network using only horizontal/vertical movement
        function findGridPath(start, end, allRoads, intersections) {
            const path = [];
            let current = { x: start.x, y: start.y };
            
            // Simple grid pathfinding - move horizontally first, then vertically
            // This ensures 90-degree turns only
            
            // Step 1: Move horizontally towards target
            if (Math.abs(current.x - end.x) > 10) {
                const horizontalTarget = { x: end.x, y: current.y };
                
                // Find horizontal road segment
                const horizontalRoad = findRoadSegment(current, horizontalTarget, allRoads, 'horizontal');
                if (horizontalRoad) {
                    // Add points along horizontal movement
                    const steps = Math.abs(horizontalTarget.x - current.x) / 50; // 50 pixel steps
                    for (let i = 1; i <= steps; i++) {
                        const stepX = current.x + (horizontalTarget.x - current.x) * (i / steps);
                        path.push({ x: stepX, y: current.y });
                    }
                    current = horizontalTarget;
                }
            }
            
            // Step 2: Move vertically towards target
            if (Math.abs(current.y - end.y) > 10) {
                const verticalTarget = { x: current.x, y: end.y };
                
                // Find vertical road segment
                const verticalRoad = findRoadSegment(current, verticalTarget, allRoads, 'vertical');
                if (verticalRoad) {
                    // Add points along vertical movement
                    const steps = Math.abs(verticalTarget.y - current.y) / 50; // 50 pixel steps
                    for (let i = 1; i <= steps; i++) {
                        const stepY = current.y + (verticalTarget.y - current.y) * (i / steps);
                        path.push({ x: current.x, y: stepY });
                    }
                    current = verticalTarget;
                }
            }
            
            return path;
        }
        
        // Find road segment that supports movement in specified direction
        function findRoadSegment(from, to, allRoads, direction) {
            const tolerance = 20;
            
            for (const road of allRoads) {
                if (direction === 'horizontal') {
                    // Check if road is horizontal and overlaps with our path
                    const isHorizontal = Math.abs(road.y1 - road.y2) < tolerance;
                    const yMatch = Math.abs(road.y1 - from.y) < tolerance || Math.abs(road.y2 - from.y) < tolerance;
                    
                    if (isHorizontal && yMatch) {
                        const roadMinX = Math.min(road.x1, road.x2);
                        const roadMaxX = Math.max(road.x1, road.x2);
                        const pathMinX = Math.min(from.x, to.x);
                        const pathMaxX = Math.max(from.x, to.x);
                        
                        // Check if road segment overlaps with our horizontal movement
                        if (roadMaxX >= pathMinX && roadMinX <= pathMaxX) {
                            return road;
                        }
                    }
                } else if (direction === 'vertical') {
                    // Check if road is vertical and overlaps with our path
                    const isVertical = Math.abs(road.x1 - road.x2) < tolerance;
                    const xMatch = Math.abs(road.x1 - from.x) < tolerance || Math.abs(road.x2 - from.x) < tolerance;
                    
                    if (isVertical && xMatch) {
                        const roadMinY = Math.min(road.y1, road.y2);
                        const roadMaxY = Math.max(road.y1, road.y2);
                        const pathMinY = Math.min(from.y, to.y);
                        const pathMaxY = Math.max(from.y, to.y);
                        
                        // Check if road segment overlaps with our vertical movement
                        if (roadMaxY >= pathMinY && roadMinY <= pathMaxY) {
                            return road;
                        }
                    }
                }
            }
            
            return null;
        }
        
        // Create parking spaces near intersections based on slider value
        function createParkingSpaces(intersections) {
            const parkingSpaceCount = parseInt(document.getElementById('parking-count').value) || 5;
            debugLog("createParkingSpaces called", { parkingSpaceCount });
            const parkingSpaces = [];
            
            if (intersections.length >= parkingSpaceCount && parkingSpaceCount > 0) {
                // Select intersections evenly distributed
                for (let i = 0; i < parkingSpaceCount; i++) {
                    const index = Math.floor(i * intersections.length / parkingSpaceCount);
                    const intersection = intersections[index];
                    
                    // Place parking space near intersection with different angles
                    const angles = [45, 135, 225, 315, 0]; // Different angles for each parking space
                    const angle = angles[i % angles.length] * Math.PI / 180;
                    const offset = 25; // Distance from intersection
                    
                    parkingSpaces.push({
                        id: i + 1,
                        x: intersection.x + Math.cos(angle) * offset,
                        y: intersection.y + Math.sin(angle) * offset,
                        nearestIntersection: intersection
                    });
                }
            }
            
            return parkingSpaces;
        }
        
        // Generate path between two parking spaces
        function generateParkingSpacePath(startParking, endParking, roadNetwork) {
            const path = [];
            
            // Start at parking space
            path.push({ x: startParking.x, y: startParking.y });
            
            // Move to nearest intersection from start parking
            path.push({ x: startParking.nearestIntersection.x, y: startParking.nearestIntersection.y });
            
            // If different intersections, find path between them
            if (startParking.nearestIntersection !== endParking.nearestIntersection) {
                const gridPath = findGridPath(
                    startParking.nearestIntersection, 
                    endParking.nearestIntersection, 
                    [...roadNetwork.primaryRoads, ...roadNetwork.secondaryRoads, 
                     ...roadNetwork.tertiaryRoads.filter((_, index) => index % 3 !== 0)], 
                    roadNetwork.intersections
                );
                path.push(...gridPath);
            }
            
            // Move from end intersection to end parking space
            path.push({ x: endParking.nearestIntersection.x, y: endParking.nearestIntersection.y });
            path.push({ x: endParking.x, y: endParking.y });
            
            return path;
        }

        // Dijkstra pathfinding between nodes
        function dijkstraPath(startNode, endNode, nodes, links) {
            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set();
            
            // Initialize distances
            for (const [nodeId, node] of nodes) {
                distances.set(nodeId, nodeId === startNode.id ? 0 : Infinity);
                unvisited.add(nodeId);
            }
            
            while (unvisited.size > 0) {
                // Find unvisited node with minimum distance
                let currentNodeId = null;
                let minDistance = Infinity;
                
                for (const nodeId of unvisited) {
                    if (distances.get(nodeId) < minDistance) {
                        minDistance = distances.get(nodeId);
                        currentNodeId = nodeId;
                    }
                }
                
                if (currentNodeId === null || minDistance === Infinity) break;
                
                unvisited.delete(currentNodeId);
                
                if (currentNodeId === endNode.id) break;
                
                // Check neighbors
                const neighbors = links.get(currentNodeId) || [];
                for (const neighborId of neighbors) {
                    if (!unvisited.has(neighborId)) continue;
                    
                    const currentNode = nodes.get(currentNodeId);
                    const neighborNode = nodes.get(neighborId);
                    const distance = Math.sqrt(
                        Math.pow(neighborNode.x - currentNode.x, 2) + 
                        Math.pow(neighborNode.y - currentNode.y, 2)
                    );
                    
                    const altDistance = distances.get(currentNodeId) + distance;
                    if (altDistance < distances.get(neighborId)) {
                        distances.set(neighborId, altDistance);
                        previous.set(neighborId, currentNodeId);
                    }
                }
            }
            
            // Reconstruct path
            const path = [];
            let currentId = endNode.id;
            
            while (currentId !== undefined) {
                path.unshift(nodes.get(currentId));
                currentId = previous.get(currentId);
            }
            
            return path.length > 1 ? path : [];
        }

        // Define explicit node-link structure for road network
        function createRoadNetworkStructure(allRoads, intersections) {
            const nodes = new Map();
            const links = new Map();
            const tolerance = 15;
            
            // Create nodes from intersections
            intersections.forEach((intersection, index) => {
                const nodeId = `node_${index}`;
                nodes.set(nodeId, {
                    id: nodeId,
                    x: intersection.x,
                    y: intersection.y,
                    connectedLinks: []
                });
            });
            
            // Create links from roads
            allRoads.forEach((road, roadIndex) => {
                const linkId = `link_${roadIndex}`;
                const roadStart = { x: road.x1, y: road.y1 };
                const roadEnd = { x: road.x2, y: road.y2 };
                
                // Find nodes at road endpoints
                let startNodeId = null;
                let endNodeId = null;
                
                for (const [nodeId, node] of nodes) {
                    const distToStart = Math.sqrt(
                        Math.pow(node.x - roadStart.x, 2) + 
                        Math.pow(node.y - roadStart.y, 2)
                    );
                    const distToEnd = Math.sqrt(
                        Math.pow(node.x - roadEnd.x, 2) + 
                        Math.pow(node.y - roadEnd.y, 2)
                    );
                    
                    if (distToStart < tolerance) {
                        startNodeId = nodeId;
                    }
                    if (distToEnd < tolerance) {
                        endNodeId = nodeId;
                    }
                }
                
                // Create link if both endpoints have nodes
                if (startNodeId && endNodeId && startNodeId !== endNodeId) {
                    const roadLength = Math.sqrt(
                        Math.pow(road.x2 - road.x1, 2) + 
                        Math.pow(road.y2 - road.y1, 2)
                    );
                    
                    const link = {
                        id: linkId,
                        startNode: startNodeId,
                        endNode: endNodeId,
                        startX: road.x1,
                        startY: road.y1,
                        endX: road.x2,
                        endY: road.y2,
                        length: roadLength,
                        road: road
                    };
                    
                    links.set(linkId, link);
                    
                    // Add link to connected nodes
                    nodes.get(startNodeId).connectedLinks.push(linkId);
                    nodes.get(endNodeId).connectedLinks.push(linkId);
                }
            });
            
            return { nodes, links };
        }
        
        // Dijkstra's algorithm using node-link structure
        function dijkstraShortestPath(nodes, links, startNodeId, endNodeId) {
            const distances = new Map();
            const previous = new Map();
            const unvisited = new Set();
            
            // Initialize distances
            for (const nodeId of nodes.keys()) {
                distances.set(nodeId, nodeId === startNodeId ? 0 : Infinity);
                unvisited.add(nodeId);
            }
            
            while (unvisited.size > 0) {
                // Find unvisited node with minimum distance
                let currentNode = null;
                let minDistance = Infinity;
                for (const nodeId of unvisited) {
                    if (distances.get(nodeId) < minDistance) {
                        minDistance = distances.get(nodeId);
                        currentNode = nodeId;
                    }
                }
                
                if (currentNode === null || minDistance === Infinity) break;
                
                unvisited.delete(currentNode);
                
                if (currentNode === endNodeId) break;
                
                // Check all links connected to current node
                const connectedLinks = nodes.get(currentNode).connectedLinks;
                for (const linkId of connectedLinks) {
                    const link = links.get(linkId);
                    const neighborNodeId = link.startNode === currentNode ? link.endNode : link.startNode;
                    
                    if (unvisited.has(neighborNodeId)) {
                        const newDistance = distances.get(currentNode) + link.length;
                        if (newDistance < distances.get(neighborNodeId)) {
                            distances.set(neighborNodeId, newDistance);
                            previous.set(neighborNodeId, {
                                nodeId: currentNode,
                                linkId: linkId
                            });
                        }
                    }
                }
            }
            
            // Reconstruct path as sequence of links
            const linkPath = [];
            let currentNode = endNodeId;
            
            while (previous.has(currentNode)) {
                const prev = previous.get(currentNode);
                linkPath.unshift(prev.linkId);
                currentNode = prev.nodeId;
            }
            
            return linkPath;
        }
        
        // Helper function to calculate total distance along a path
        function calculateTotalPathDistance(points) {
            let totalDistance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += Math.sqrt(
                    Math.pow(points[i + 1].x - points[i].x, 2) + 
                    Math.pow(points[i + 1].y - points[i].y, 2)
                );
            }
            return totalDistance;
        }
        
        // Generate a path for a vehicle using node-link structure
        function generateVehiclePath(startRoad, endRoad, allRoads, intersections) {
            const points = [];
            
            // Create node-link structure
            const { nodes, links } = createRoadNetworkStructure(allRoads, intersections);
            
            // Find nodes closest to start and end roads
            const tolerance = 15;
            let startNodeId = null;
            let endNodeId = null;
            
            for (const [nodeId, node] of nodes) {
                // Check if node is on start road
                const distToStartRoad = distanceToLineSegment(
                    node.x, node.y,
                    startRoad.x1, startRoad.y1, startRoad.x2, startRoad.y2
                );
                if (distToStartRoad < tolerance) {
                    startNodeId = nodeId;
                }
                
                // Check if node is on end road
                const distToEndRoad = distanceToLineSegment(
                    node.x, node.y,
                    endRoad.x1, endRoad.y1, endRoad.x2, endRoad.y2
                );
                if (distToEndRoad < tolerance) {
                    endNodeId = nodeId;
                }
            }
            
            if (!startNodeId || !endNodeId) {
                if (window.debugMode) {
                    debugLog("Vehicle path fallback - no valid nodes found", { 
                        startNodeId, 
                        endNodeId,
                        availableNodes: Array.from(nodes.keys()),
                        startRoad: `(${startRoad.x1},${startRoad.y1})->(${startRoad.x2},${startRoad.y2})`,
                        endRoad: `(${endRoad.x1},${endRoad.y1})->(${endRoad.x2},${endRoad.y2})`
                    });
                }
                
                // Try to find different start and end roads that have intersections
                let alternativeStartRoad = null;
                let alternativeEndRoad = null;
                
                for (const road of allRoads) {
                    let hasIntersection = false;
                    for (const [nodeId, node] of nodes) {
                        const distToRoad = distanceToLineSegment(
                            node.x, node.y,
                            road.x1, road.y1, road.x2, road.y2
                        );
                        if (distToRoad < tolerance) {
                            hasIntersection = true;
                            break;
                        }
                    }
                    
                    if (hasIntersection) {
                        if (!alternativeStartRoad) {
                            alternativeStartRoad = road;
                        } else if (!alternativeEndRoad && road !== alternativeStartRoad) {
                            alternativeEndRoad = road;
                            break;
                        }
                    }
                }
                
                if (alternativeStartRoad && alternativeEndRoad) {
                    // Recursively try with roads that have intersections
                    return generateVehiclePath(alternativeStartRoad, alternativeEndRoad, allRoads, intersections);
                }
                
                // Final fallback: create simple path along single road
                const numPoints = 5;
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    points.push({
                        x: startRoad.x1 + (startRoad.x2 - startRoad.x1) * t,
                        y: startRoad.y1 + (startRoad.y2 - startRoad.y1) * t
                    });
                }
                return points;
            }
            
            // Find shortest path using Dijkstra
            const linkPath = dijkstraShortestPath(nodes, links, startNodeId, endNodeId);
            
            if (window.debugMode) {
                debugLog("Vehicle link path found", { 
                    startNode: startNodeId,
                    endNode: endNodeId,
                    pathLength: linkPath.length,
                    links: linkPath,
                    totalNodes: nodes.size,
                    totalLinks: links.size,
                    startRoad: `(${startRoad.x1},${startRoad.y1})->(${startRoad.x2},${startRoad.y2})`,
                    endRoad: `(${endRoad.x1},${endRoad.y1})->(${endRoad.x2},${endRoad.y2})`
                });
            }
            
            // Generate points strictly along the link path
            if (linkPath.length === 0) {
                // Same node - travel along single road
                const numPoints = 5;
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    points.push({
                        x: startRoad.x1 + (startRoad.x2 - startRoad.x1) * t,
                        y: startRoad.y1 + (startRoad.y2 - startRoad.y1) * t
                    });
                }
            } else {
                // Travel along each link in the path
                for (let linkIndex = 0; linkIndex < linkPath.length; linkIndex++) {
                    const linkId = linkPath[linkIndex];
                    const link = links.get(linkId);
                    
                    // Determine direction of travel on this link
                    let linkStartX, linkStartY, linkEndX, linkEndY;
                    
                    if (linkIndex === 0) {
                        // First link: determine direction based on which node we're coming from
                        const currentNode = nodes.get(startNodeId);
                        const startNodeDist = Math.sqrt(
                            Math.pow(currentNode.x - link.startX, 2) + 
                            Math.pow(currentNode.y - link.startY, 2)
                        );
                        const endNodeDist = Math.sqrt(
                            Math.pow(currentNode.x - link.endX, 2) + 
                            Math.pow(currentNode.y - link.endY, 2)
                        );
                        
                        if (startNodeDist < endNodeDist) {
                            // Travel from start to end of link
                            linkStartX = link.startX;
                            linkStartY = link.startY;
                            linkEndX = link.endX;
                            linkEndY = link.endY;
                        } else {
                            // Travel from end to start of link
                            linkStartX = link.endX;
                            linkStartY = link.endY;
                            linkEndX = link.startX;
                            linkEndY = link.startY;
                        }
                    } else {
                        // Subsequent links: continue from previous link's end point
                        const prevLink = links.get(linkPath[linkIndex - 1]);
                        const prevEndX = points[points.length - 1].x;
                        const prevEndY = points[points.length - 1].y;
                        
                        // Determine which end of current link connects to previous
                        const startDist = Math.sqrt(
                            Math.pow(prevEndX - link.startX, 2) + 
                            Math.pow(prevEndY - link.startY, 2)
                        );
                        const endDist = Math.sqrt(
                            Math.pow(prevEndX - link.endX, 2) + 
                            Math.pow(prevEndY - link.endY, 2)
                        );
                        
                        if (startDist < endDist) {
                            linkStartX = link.startX;
                            linkStartY = link.startY;
                            linkEndX = link.endX;
                            linkEndY = link.endY;
                        } else {
                            linkStartX = link.endX;
                            linkStartY = link.endY;
                            linkEndX = link.startX;
                            linkEndY = link.startY;
                        }
                    }
                    
                    // Add points along this link with smooth transitions at intersections
                    const numSegments = 6; // More segments for smoother turning
                    const startIdx = linkIndex === 0 ? 0 : 1; // Skip first point for subsequent links
                    
                    for (let i = startIdx; i <= numSegments; i++) {
                        const t = i / numSegments;
                        points.push({
                            x: linkStartX + (linkEndX - linkStartX) * t,
                            y: linkStartY + (linkEndY - linkStartY) * t
                        });
                    }
                    
                    // Add smooth transition points at intersections for better turning
                    if (linkIndex < linkPath.length - 1) {
                        const nextLinkId = linkPath[linkIndex + 1];
                        const nextLink = links.get(nextLinkId);
                        
                        // Add a small curve at intersection for realistic turning
                        const intersectionX = linkEndX;
                        const intersectionY = linkEndY;
                        
                        // Determine next link direction
                        let nextLinkStartX, nextLinkStartY;
                        const nextStartDist = Math.sqrt(
                            Math.pow(intersectionX - nextLink.startX, 2) + 
                            Math.pow(intersectionY - nextLink.startY, 2)
                        );
                        const nextEndDist = Math.sqrt(
                            Math.pow(intersectionX - nextLink.endX, 2) + 
                            Math.pow(intersectionY - nextLink.endY, 2)
                        );
                        
                        if (nextStartDist < nextEndDist) {
                            nextLinkStartX = nextLink.startX;
                            nextLinkStartY = nextLink.startY;
                        } else {
                            nextLinkStartX = nextLink.endX;
                            nextLinkStartY = nextLink.endY;
                        }
                        
                        // Add intermediate point for smooth turning
                        const turnRadius = 5;
                        const currentDir = Math.atan2(linkEndY - linkStartY, linkEndX - linkStartX);
                        const nextDir = Math.atan2(nextLinkStartY - intersectionY, nextLinkStartX - intersectionX);
                        const avgDir = (currentDir + nextDir) / 2;
                        
                        points.push({
                            x: intersectionX + Math.cos(avgDir) * turnRadius,
                            y: intersectionY + Math.sin(avgDir) * turnRadius
                        });
                    }
                }
            }
            
            return points;
        }
        
        // Find roads connected to the given road through intersections
        function findConnectedRoads(road, allRoads, intersections) {
            const connected = [];
            const tolerance = 10;
            
            // Check both ends of the road for intersections
            const roadEnds = [
                { x: road.x1, y: road.y1 },
                { x: road.x2, y: road.y2 }
            ];
            
            for (const roadEnd of roadEnds) {
                // Find intersection at this road end
                const intersection = intersections.find(int => 
                    Math.sqrt(Math.pow(int.x - roadEnd.x, 2) + Math.pow(int.y - roadEnd.y, 2)) < tolerance
                );
                
                if (intersection) {
                    // Find other roads connected to this intersection
                    for (const otherRoad of allRoads) {
                        if (otherRoad === road) continue;
                        
                        const otherEnds = [
                            { x: otherRoad.x1, y: otherRoad.y1 },
                            { x: otherRoad.x2, y: otherRoad.y2 }
                        ];
                        
                        for (const otherEnd of otherEnds) {
                            const dist = Math.sqrt(
                                Math.pow(intersection.x - otherEnd.x, 2) +
                                Math.pow(intersection.y - otherEnd.y, 2)
                            );
                            
                            if (dist < tolerance && !connected.includes(otherRoad)) {
                                connected.push(otherRoad);
                            }
                        }
                    }
                }
            }
            
            return connected;
        }
        
        // Render the road network
        function renderRoadNetwork() {
            const svg = d3.select(".visualization-container svg");
            
            // Clear previous roads and background elements
            svg.selectAll(".road").remove();
            svg.selectAll(".intersection").remove();
            svg.selectAll(".background").remove();
            
            // Add background elements
            // Green grass background
            svg.append("rect")
                .attr("class", "background grass")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", config.width)
                .attr("height", config.height)
                .attr("fill", "#9DE04F");
                
            // Add some brown land patches
            const landPatches = [
                {x: 50, y: 50, width: 150, height: 100},
                {x: 300, y: 200, width: 200, height: 150},
                {x: 600, y: 100, width: 150, height: 120},
                {x: 100, y: 350, width: 180, height: 100}
            ];
            
            landPatches.forEach(patch => {
                svg.append("rect")
                    .attr("class", "background land")
                    .attr("x", patch.x)
                    .attr("y", patch.y)
                    .attr("width", patch.width)
                    .attr("height", patch.height)
                    .attr("fill", "#C68642")
                    .attr("rx", 20)
                    .attr("ry", 20);
            });
            
            // Render roads function
            function renderRoads() {
                const svg = d3.select(".visualization-container svg");
                svg.selectAll(".road").remove();
                svg.selectAll(".parking-space").remove();
                svg.selectAll(".parking-label").remove();
                
                const roadNetwork = roadLayouts[currentRoadLayout];
                
                // Render primary roads (thick black lines)
                svg.selectAll(".primary-road")
                    .data(roadNetwork.primaryRoads)
                    .enter()
                    .append("line")
                    .attr("class", "road primary-road")
                    .attr("x1", d => d.x1)
                    .attr("y1", d => d.y1)
                    .attr("x2", d => d.x2)
                    .attr("y2", d => d.y2)
                    .attr("stroke", "black")
                    .attr("stroke-width", 6);
                
                // Render secondary roads (medium gray lines)
                svg.selectAll(".secondary-road")
                    .data(roadNetwork.secondaryRoads)
                    .enter()
                    .append("line")
                    .attr("class", "road secondary-road")
                    .attr("x1", d => d.x1)
                    .attr("y1", d => d.y1)
                    .attr("x2", d => d.x2)
                    .attr("y2", d => d.y2)
                    .attr("stroke", "#666")
                    .attr("stroke-width", 4);
                
                // Render tertiary roads (thin light gray lines), excluding rivers
                const nonRiverTertiary = roadNetwork.tertiaryRoads.filter((_, index) => index % 3 !== 0);
                svg.selectAll(".tertiary-road")
                    .data(nonRiverTertiary)
                    .enter()
                    .append("line")
                    .attr("class", "road tertiary-road")
                    .attr("x1", d => d.x1)
                    .attr("y1", d => d.y1)
                    .attr("x2", d => d.x2)
                    .attr("y2", d => d.y2)
                    .attr("stroke", "#999")
                    .attr("stroke-width", 2);
                
                // Render rivers (blue lines from every third tertiary road)
                const rivers = roadNetwork.tertiaryRoads.filter((_, index) => index % 3 === 0);
                svg.selectAll(".river")
                    .data(rivers)
                    .enter()
                    .append("line")
                    .attr("class", "river")
                    .attr("x1", d => d.x1)
                    .attr("y1", d => d.y1)
                    .attr("x2", d => d.x2)
                    .attr("y2", d => d.y2)
                    .attr("stroke", "blue")
                    .attr("stroke-width", 3);
                
                // Render intersections
                svg.selectAll(".intersection")
                    .data(roadNetwork.intersections)
                    .enter()
                    .append("circle")
                    .attr("class", "intersection")
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("r", 4)
                    .attr("fill", "red");
                
                // Add 5 parking spaces near intersections
                const parkingSpaces = createParkingSpaces(roadNetwork.intersections);
                
                // Render parking spaces as squares
                svg.selectAll(".parking-space")
                    .data(parkingSpaces)
                    .enter()
                    .append("rect")
                    .attr("class", "parking-space")
                    .attr("x", d => d.x - 10)
                    .attr("y", d => d.y - 10)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("fill", "yellow")
                    .attr("stroke", "orange")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.8);
                
                // Add parking space labels
                svg.selectAll(".parking-label")
                    .data(parkingSpaces)
                    .enter()
                    .append("text")
                    .attr("class", "parking-label")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y + 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "10px")
                    .attr("font-weight", "bold")
                    .attr("fill", "black")
                    .text(d => `P${d.id}`);
            }
            
            renderRoads();
            
            // Draw primary roads
            roadNetwork.primaryRoads.forEach(road => {
                svg.append("line")
                    .attr("class", "road primary-road")
                    .attr("x1", road.x1)
                    .attr("y1", road.y1)
                    .attr("x2", road.x2)
                    .attr("y2", road.y2)
                    .attr("stroke", config.roadColors.primary)
                    .attr("stroke-width", 8 * roadMapScale);
            });
            
            // Draw secondary roads
            roadNetwork.secondaryRoads.forEach(road => {
                svg.append("line")
                    .attr("class", "road secondary-road")
                    .attr("x1", road.x1)
                    .attr("y1", road.y1)
                    .attr("x2", road.x2)
                    .attr("y2", road.y2)
                    .attr("stroke", config.roadColors.secondary)
                    .attr("stroke-width", 6 * roadMapScale);
            });
            
            // Clear river segments array before adding new ones
            riverSegments = [];
            
            // Draw tertiary roads - some as rivers
            roadNetwork.tertiaryRoads.forEach((road, index) => {
                // Make every third tertiary road a river
                const isRiver = index % 3 === 0;
                
                svg.append("line")
                    .attr("class", isRiver ? "road river" : "road tertiary-road")
                    .attr("x1", road.x1)
                    .attr("y1", road.y1)
                    .attr("x2", road.x2)
                    .attr("y2", road.y2)
                    .attr("stroke", isRiver ? "#4FC3F7" : config.roadColors.tertiary)
                    .attr("stroke-width", isRiver ? 8 * roadMapScale : 4 * roadMapScale)
                    .attr("stroke-linecap", "round")
                    .attr("stroke-opacity", isRiver ? 0.8 : 1);
                
                // Add wavy pattern for rivers
                if (isRiver) {
                    // Store river segment for collision detection
                    riverSegments.push({
                        x1: road.x1,
                        y1: road.y1,
                        x2: road.x2,
                        y2: road.y2,
                        width: 8 * roadMapScale
                    });
                    
                    // Add small decorative elements to make rivers look more natural
                    const midX = (road.x1 + road.x2) / 2;
                    const midY = (road.y1 + road.y2) / 2;
                    
                    svg.append("circle")
                        .attr("class", "background river-detail")
                        .attr("cx", midX)
                        .attr("cy", midY)
                        .attr("r", 3 * roadMapScale)
                        .attr("fill", "#29B6F6");
                }
            });
            
            // Draw intersections
            roadNetwork.intersections.forEach(intersection => {
                svg.append("circle")
                    .attr("class", "intersection")
                    .attr("cx", intersection.x)
                    .attr("cy", intersection.y)
                    .attr("r", intersection.r * roadMapScale)
                    .attr("fill", "#555");
            });
            
            debugLog("Rendered road network", { layout: roadNetwork.name, scale: roadMapScale });
        }
        
        // Render vehicles moving along roads
        function renderVehicles(progress = 1.0) {
            const svg = d3.select(".visualization-container svg");
            svg.selectAll(".vehicle-group").remove();
            
            if (currentVehicleData.length === 0) return;
            
            // Debug: Draw vehicle paths to verify they follow roads
            if (window.debugMode) {
                svg.selectAll(".vehicle-path-debug").remove();
                currentVehicleData.forEach((vehicle, index) => {
                    const lineGenerator = d3.line()
                        .x(d => d.x)
                        .y(d => d.y)
                        .curve(d3.curveLinear);
                    
                    svg.append("path")
                        .attr("class", "vehicle-path-debug")
                        .attr("d", lineGenerator(vehicle.points))
                        .attr("stroke", vehicle.color)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .attr("fill", "none")
                        .attr("opacity", 0.5);
                });
            }
            
            const vehicleGroups = svg.selectAll(".vehicle-group")
                .data(currentVehicleData)
                .enter()
                .append("g")
                .attr("class", "vehicle-group");
                
            vehicleGroups.each(function(vehicle) {
                const group = d3.select(this);
                const startTime = vehicle.startTime || 0;
                const endTime = vehicle.endTime || 1.0;
                
                if (progress < startTime) return;
                
                const points = vehicle.points;
                let vehicleProgress;
                if (progress <= startTime) vehicleProgress = 0;
                else if (progress >= endTime) vehicleProgress = 1.0;
                else vehicleProgress = (progress - startTime) / (endTime - startTime);
                
                // Calculate current position along the path with improved interpolation
                if (vehicleProgress > 0 && points.length > 0) {
                    let x, y, angle = 0;
                    
                    if (vehicleProgress >= 1.0) {
                        // Vehicle has reached the end - use final point
                        const finalPoint = points[points.length - 1];
                        x = finalPoint.x;
                        y = finalPoint.y;
                        
                        // Calculate angle from second-to-last point for proper orientation
                        if (points.length > 1) {
                            const prevPoint = points[points.length - 2];
                            angle = Math.atan2(finalPoint.y - prevPoint.y, finalPoint.x - prevPoint.x) * 180 / Math.PI;
                        }
                    } else {
                        // Normal interpolation along path
                        const totalDistance = calculateTotalPathDistance(points);
                        const targetDistance = vehicleProgress * totalDistance;
                        
                        let currentDistance = 0;
                        let segmentIndex = 0;
                        
                        // Find which segment contains the target distance
                        for (let i = 0; i < points.length - 1; i++) {
                            const segmentDistance = Math.sqrt(
                                Math.pow(points[i + 1].x - points[i].x, 2) + 
                                Math.pow(points[i + 1].y - points[i].y, 2)
                            );
                            
                            if (currentDistance + segmentDistance >= targetDistance) {
                                segmentIndex = i;
                                break;
                            }
                            currentDistance += segmentDistance;
                        }
                        
                        // Interpolate within the found segment
                        const currentPoint = points[segmentIndex];
                        const nextPoint = points[Math.min(segmentIndex + 1, points.length - 1)];
                        const segmentDistance = Math.sqrt(
                            Math.pow(nextPoint.x - currentPoint.x, 2) + 
                            Math.pow(nextPoint.y - currentPoint.y, 2)
                        );
                        
                        const remainingDistance = targetDistance - currentDistance;
                        const segmentProgress = segmentDistance > 0 ? remainingDistance / segmentDistance : 0;
                        
                        x = currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress;
                        y = currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress;
                        
                        // Calculate movement direction for smooth turning
                        if (currentPoint !== nextPoint) {
                            angle = Math.atan2(nextPoint.y - currentPoint.y, nextPoint.x - currentPoint.x) * 180 / Math.PI;
                        }
                    }
                    
                    // Create vehicle icon group at the current position
                    const vehicleGroup = group.append("g")
                        .attr("transform", `translate(${x - 10}, ${y - 8})`);
                    
                    // Vehicle body (rectangle with rounded corners)
                    vehicleGroup.append("rect")
                        .attr("x", 2)
                        .attr("y", 4)
                        .attr("width", 16)
                        .attr("height", 8)
                        .attr("rx", 2)
                        .attr("ry", 2)
                        .attr("fill", vehicle.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 1)
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    // Vehicle windows
                    vehicleGroup.append("rect")
                        .attr("x", 4)
                        .attr("y", 5.5)
                        .attr("width", 5)
                        .attr("height", 5)
                        .attr("rx", 1)
                        .attr("fill", "#87CEEB")
                        .attr("opacity", 0.8)
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    vehicleGroup.append("rect")
                        .attr("x", 11)
                        .attr("y", 5.5)
                        .attr("width", 5)
                        .attr("height", 5)
                        .attr("rx", 1)
                        .attr("fill", "#87CEEB")
                        .attr("opacity", 0.8)
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    // Vehicle wheels
                    vehicleGroup.append("circle")
                        .attr("cx", 5)
                        .attr("cy", 12.5)
                        .attr("r", 1.5)
                        .attr("fill", "#333")
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    vehicleGroup.append("circle")
                        .attr("cx", 15)
                        .attr("cy", 12.5)
                        .attr("r", 1.5)
                        .attr("fill", "#333")
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    vehicleGroup.append("circle")
                        .attr("cx", 5)
                        .attr("cy", 3.5)
                        .attr("r", 1.5)
                        .attr("fill", "#333")
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    vehicleGroup.append("circle")
                        .attr("cx", 15)
                        .attr("cy", 3.5)
                        .attr("r", 1.5)
                        .attr("fill", "#333")
                        .attr("transform", `rotate(${angle} 10 8)`);
                    
                    // Vehicle label
                    group.append("text")
                        .attr("x", x)
                        .attr("y", y - 15)
                        .attr("text-anchor", "middle")
                        .attr("fill", vehicle.color)
                        .attr("font-size", "10px")
                        .attr("font-weight", "bold")
                        .text(vehicle.id);
                }
            });
        }
        
        // Render trajectories with animation progress
        function renderTrajectories(progress = 1.0) {
            const svg = d3.select(".visualization-container svg");
            svg.selectAll(".trajectory-group").remove();
            if (currentTrajectoryData.length === 0) {
                generateTrajectories();
            }
            if (currentVehicleData.length === 0) {
                generateVehicles();
            }
            
            // Render vehicles first (so they appear behind rabbits)
            renderVehicles(progress);
            const trajectoryGroups = svg.selectAll(".trajectory-group")
                .data(currentTrajectoryData)
                .enter()
                .append("g")
                .attr("class", "trajectory-group");
            trajectoryGroups.each(function(trajectory) {
                const group = d3.select(this);
                const startTime = trajectory.startTime || 0;
                const endTime = trajectory.endTime || 1.0;
                if (progress < startTime) return;
                const points = trajectory.points;
                let trajectoryProgress;
                if (progress <= startTime) trajectoryProgress = 0;
                else if (progress >= endTime) trajectoryProgress = 1.0;
                else trajectoryProgress = (progress - startTime) / (endTime - startTime);
                const numPointsToShow = Math.max(2, Math.floor(points.length * trajectoryProgress));
                const visiblePoints = points.slice(0, numPointsToShow);
                const lineGenerator = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveCatmullRom.alpha(0.5));
                group.append("path")
                    .attr("d", lineGenerator(visiblePoints))
                    .attr("stroke", trajectory.color)
                    .attr("stroke-width", 3)
                    .attr("fill", "none")
                    .attr("stroke-dasharray", "5,3")
                    .attr("opacity", 0.7);
                group.selectAll(".trajectory-point")
                    .data(visiblePoints)
                    .enter()
                    .append("circle")
                    .attr("class", "trajectory-point")
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("r", 3)
                    .attr("fill", trajectory.color);
                if (visiblePoints.length >= 2 && trajectoryProgress < 1.0) {
                    const lastPoint = visiblePoints[visiblePoints.length - 1];
                    const prevPoint = visiblePoints[visiblePoints.length - 2];
                    const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x);
                    group.append("polygon")
                        .attr("points", "0,-5 10,0 0,5")
                        .attr("transform", `translate(${lastPoint.x},${lastPoint.y}) rotate(${angle * 180 / Math.PI})`)
                        .attr("fill", trajectory.color);
                }
                if (visiblePoints.length > 0) {
                    const lastPoint = visiblePoints[visiblePoints.length - 1];
                    group.append("text")
                        .attr("x", lastPoint.x + 10)
                        .attr("y", lastPoint.y - 10)
                        .attr("fill", trajectory.color)
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .text(trajectory.id);
                }
                
                // Add rabbit icon that moves along the trajectory
                if (trajectoryProgress > 0 && points.length > 0 && visiblePoints.length > 0) {
                    // Get the current position of the rabbit based on visible points
                    const currentPoint = visiblePoints[visiblePoints.length - 1];
                    
                    // Create rabbit icon group at the current position
                    const rabbitGroup = group.append("g")
                        .attr("transform", `translate(${currentPoint.x - 12}, ${currentPoint.y - 12})`);
                    
                    // Calculate movement direction for rabbit orientation
                    let angle = 0;
                    if (visiblePoints.length > 1) {
                        const prevPoint = visiblePoints[visiblePoints.length - 2];
                        angle = Math.atan2(currentPoint.y - prevPoint.y, currentPoint.x - prevPoint.x) * 180 / Math.PI;
                    }
                    
                    // Rabbit background circle
                    rabbitGroup.append("circle")
                        .attr("cx", 12)
                        .attr("cy", 12)
                        .attr("r", 12)
                        .attr("fill", "white")
                        .attr("stroke", trajectory.color)
                        .attr("stroke-width", 1.5);
                    
                    // Inner group for rabbit that can be rotated to face direction of movement
                    const rabbitInnerGroup = rabbitGroup.append("g")
                        .attr("transform", `translate(12, 12) rotate(${angle}) translate(-12, -12)`);
                    
                    // Rabbit body - cuter rounded shape
                    rabbitInnerGroup.append("path")
                        .attr("d", "M12,6 C9,6 7,8 7,11 C7,14 9,16 12,16 C15,16 17,14 17,11 C17,8 15,6 12,6 Z")
                        .attr("fill", trajectory.color);
                    
                    // Rabbit ears - rounder and cuter
                    rabbitInnerGroup.append("path")
                        .attr("d", "M9,8 C9,8 8,4 9,2 C10,1 11,3 11,6 M15,8 C15,8 16,4 15,2 C14,1 13,3 13,6")
                        .attr("fill", trajectory.color);
                    
                    // Rabbit face - cute features
                    // Bigger eyes with white highlights
                    rabbitInnerGroup.append("circle")
                        .attr("cx", 10)
                        .attr("cy", 10)
                        .attr("r", 1.5)
                        .attr("fill", "black");
                    rabbitInnerGroup.append("circle")
                        .attr("cx", 14)
                        .attr("cy", 10)
                        .attr("r", 1.5)
                        .attr("fill", "black");
                    
                    // Eye highlights
                    rabbitInnerGroup.append("circle")
                        .attr("cx", 10.5)
                        .attr("cy", 9.5)
                        .attr("r", 0.5)
                        .attr("fill", "white");
                    rabbitInnerGroup.append("circle")
                        .attr("cx", 14.5)
                        .attr("cy", 9.5)
                        .attr("r", 0.5)
                        .attr("fill", "white");
                    
                    // Cute nose
                    rabbitInnerGroup.append("circle")
                        .attr("cx", 12)
                        .attr("cy", 12)
                        .attr("r", 1)
                        .attr("fill", "pink");
                    
                    // Whiskers
                    rabbitInnerGroup.append("path")
                        .attr("d", "M11,12 L8,11 M11,12.5 L8,12.5 M11,13 L8,14 M13,12 L16,11 M13,12.5 L16,12.5 M13,13 L16,14")
                        .attr("stroke", "white")
                        .attr("stroke-width", 0.5)
                        .attr("fill", "none");
                }
                
                // Add carrot icon at the end point - always visible
                if (points.length > 0) {
                    const endPoint = points[points.length - 1];
                    
                    // Find a safe position for the carrot (not in a river)
                    // Pass the trajectory ID to ensure consistent positioning
                    const safePosition = findSafeCarrotPosition(endPoint, trajectory.id);
                    
                    // Create carrot icon group
                    const carrotGroup = group.append("g")
                        .attr("transform", `translate(${safePosition.x - 12}, ${safePosition.y - 12})`);
                    
                    // Carrot background circle
                    carrotGroup.append("circle")
                        .attr("cx", 12)
                        .attr("cy", 12)
                        .attr("r", 12)
                        .attr("fill", "white")
                        .attr("stroke", trajectory.color)
                        .attr("stroke-width", 1.5);
                    
                    // Carrot body - more recognizable carrot shape
                    carrotGroup.append("path")
                        .attr("d", "M12,20 L8,8 C8,6 10,4 12,4 C14,4 16,6 16,8 L12,20 Z")
                        .attr("fill", "#ff7f0e");
                    
                    // Carrot texture lines
                    carrotGroup.append("path")
                        .attr("d", "M10,8 L14,8 M9,11 L15,11 M9,14 L15,14 M10,17 L14,17")
                        .attr("stroke", "#e67300")
                        .attr("stroke-width", 0.5)
                        .attr("fill", "none");
                    
                    // Carrot leaves/greens
                    carrotGroup.append("path")
                        .attr("d", "M12,4 C12,4 10,2 8,3 C12,1 12,1 16,3 C14,2 12,4 12,4")
                        .attr("fill", "#2ca02c");
                    
                    carrotGroup.append("path")
                        .attr("d", "M12,4 L12,1 M10,2 L14,2")
                        .attr("stroke", "#2ca02c")
                        .attr("stroke-width", 1)
                        .attr("fill", "none");
                }
            });
            updateLegend(currentTrajectoryData);
        }
        
        // Update the legend with current trajectories
        function updateLegend(trajectories) {
            // Get the legend container
            const legend = document.getElementById("legend");
            legend.innerHTML = ""; // Clear previous legend
            
            // Create a container for the legend items
            const legendContainer = document.createElement("div");
            legendContainer.style.display = "flex";
            legendContainer.style.flexWrap = "wrap";
            legendContainer.style.justifyContent = "center";
            legendContainer.style.width = "100%";
            legend.appendChild(legendContainer);
            
            trajectories.forEach(trajectory => {
                // Create a legend item container
                const legendItem = document.createElement("div");
                legendItem.className = "legend-item";
                legendItem.style.display = "flex";
                legendItem.style.alignItems = "center";
                legendItem.style.margin = "5px 15px";
                legendItem.style.minWidth = "120px";
                legendItem.style.justifyContent = "flex-start";
                
                // Create SVG for rabbit icon in legend
                const iconSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                iconSvg.setAttribute("width", "24");
                iconSvg.setAttribute("height", "24");
                iconSvg.setAttribute("class", "legend-icon");
                iconSvg.style.marginRight = "15px";
                
                // Rabbit background circle
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", "12");
                circle.setAttribute("cy", "12");
                circle.setAttribute("r", "12");
                circle.setAttribute("fill", "white");
                circle.setAttribute("stroke", trajectory.color);
                circle.setAttribute("stroke-width", "1.5");
                iconSvg.appendChild(circle);
                
                // Rabbit body
                const body = document.createElementNS("http://www.w3.org/2000/svg", "path");
                body.setAttribute("d", "M12,6 C9,6 7,8 7,11 C7,14 9,16 12,16 C15,16 17,14 17,11 C17,8 15,6 12,6 Z");
                body.setAttribute("fill", trajectory.color);
                iconSvg.appendChild(body);
                
                // Rabbit ears
                const ears = document.createElementNS("http://www.w3.org/2000/svg", "path");
                ears.setAttribute("d", "M9,8 C9,8 8,4 9,2 C10,1 11,3 11,6 M15,8 C15,8 16,4 15,2 C14,1 13,3 13,6");
                ears.setAttribute("fill", trajectory.color);
                iconSvg.appendChild(ears);
                
                // Rabbit eyes
                const leftEye = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                leftEye.setAttribute("cx", "10");
                leftEye.setAttribute("cy", "10");
                leftEye.setAttribute("r", "1.5");
                leftEye.setAttribute("fill", "black");
                iconSvg.appendChild(leftEye);
                
                const rightEye = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                rightEye.setAttribute("cx", "14");
                rightEye.setAttribute("cy", "10");
                rightEye.setAttribute("r", "1.5");
                rightEye.setAttribute("fill", "black");
                iconSvg.appendChild(rightEye);
                
                // Eye highlights
                const leftHighlight = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                leftHighlight.setAttribute("cx", "10.5");
                leftHighlight.setAttribute("cy", "9.5");
                leftHighlight.setAttribute("r", "0.5");
                leftHighlight.setAttribute("fill", "white");
                iconSvg.appendChild(leftHighlight);
                
                const rightHighlight = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                rightHighlight.setAttribute("cx", "14.5");
                rightHighlight.setAttribute("cy", "9.5");
                rightHighlight.setAttribute("r", "0.5");
                rightHighlight.setAttribute("fill", "white");
                iconSvg.appendChild(rightHighlight);
                
                // Nose
                const nose = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                nose.setAttribute("cx", "12");
                nose.setAttribute("cy", "12");
                nose.setAttribute("r", "1");
                nose.setAttribute("fill", "pink");
                iconSvg.appendChild(nose);
                
                // Add the icon to the legend item
                legendItem.appendChild(iconSvg);
                
                // Create a container for the label with proper spacing
                const labelContainer = document.createElement("div");
                labelContainer.style.paddingLeft = "30px"; // Add more space between icon and text
                labelContainer.style.position = "relative";
                
                // Add the label
                const label = document.createElement("span");
                label.textContent = trajectory.id;
                label.style.fontSize = "14px";
                label.style.fontWeight = "500";
                label.style.whiteSpace = "nowrap";
                labelContainer.appendChild(label);
                
                legendItem.appendChild(labelContainer);
                
                // Add the legend item to the container
                legendContainer.appendChild(legendItem);
            });
        }
        
        // Animate trajectories with easing for more realistic motion
        function animateTrajectories() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            const completionMessage = document.getElementById('completion-message');
            completionMessage.style.opacity = 0;
            
            animationStartTime = Date.now();
            
            // Easing function for smoother acceleration/deceleration
            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            function animate() {
                const elapsed = Date.now() - animationStartTime;
                const rawProgress = Math.min(1.0, elapsed / config.animationDuration);
                
                // Apply easing for smoother motion
                const progress = easeInOutCubic(rawProgress);
                
                renderTrajectories(progress);
                
                if (rawProgress < 1.0) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    animationId = null;
                    showCompletionMessage();
                }
            }
            
            animationId = requestAnimationFrame(animate);
            debugLog("Started animation with realistic motion");
        }
        
        // Show completion message
        function showCompletionMessage() {
            const completionMessage = document.getElementById('completion-message');
            completionMessage.textContent = "Animation Complete";
            completionMessage.style.opacity = 1;
            
            setTimeout(() => {
                completionMessage.style.opacity = 0;
            }, 3000);
            
            debugLog("Animation completed");
        }
        
        // Initialize the visualization
        function initialize() {
            // Set up SVG
            const svg = d3.select(".visualization-container svg")
                .attr("width", config.width)
                .attr("height", config.height);
            
            // Render initial road network
            renderRoadNetwork();
            
            // Generate and render trajectories and vehicles after initialization
            setTimeout(() => {
                generateTrajectories();
                generateVehicles();
                renderTrajectories(0);
            }, 100);
            
            // Set up event listeners
            document.getElementById('update-btn').addEventListener('click', () => {
                debugLog("Update button clicked - reinitializing all elements");
                renderRoads();
                generateTrajectories();
                generateVehicles();
                renderTrajectories(0);
                debugLog("Updated trajectories and vehicles based on current input values");
            });
            
            document.getElementById('play-btn').addEventListener('click', () => {
                animateTrajectories();
            });
            
            document.getElementById('reset-btn').addEventListener('click', () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                // Reset all input values to defaults using getElementById
                document.getElementById('object-count').value = 5;
                document.getElementById('vehicle-count').value = 5;
                document.getElementById('parking-count').value = 5;
                document.getElementById('road-size').value = 1.0;
                
                // Reset scale and regenerate everything
                roadMapScale = 1.0;
                renderRoads();
                generateTrajectories();
                generateVehicles();
                renderTrajectories(0);
                debugLog("Reset animation and all values");
            });
            
            document.getElementById('layout-selector').addEventListener('change', (e) => {
                currentLayoutIndex = parseInt(e.target.value);
                roadNetwork = roadLayouts[currentLayoutIndex];
                renderRoadNetwork();
                generateTrajectories();
                renderTrajectories(0);
                debugLog("Changed road layout", { layout: roadNetwork.name });
            });
            
            // Object count input
            const objectCountInput = document.getElementById('object-count');
            
            function updateAll() {
                debugLog("Updating all elements");
                generateTrajectories();
                generateVehicles();
                renderRoads();
                renderTrajectories(0);
            }
            
            objectCountInput.addEventListener('change', updateAll);
            objectCountInput.addEventListener('input', updateAll);
            
            // Vehicle count input
            const vehicleCountInput = document.getElementById('vehicle-count');
            
            vehicleCountInput.addEventListener('change', updateAll);
            vehicleCountInput.addEventListener('input', updateAll);
            
            // Parking count input event listener
            const parkingCountInput = document.getElementById('parking-count');
            
            parkingCountInput.addEventListener('change', updateAll);
            parkingCountInput.addEventListener('input', updateAll);
            
            // Road size input
            const roadSizeInput = document.getElementById('road-size');
            
            document.getElementById('apply-size-btn').addEventListener('click', () => {
                roadMapScale = parseFloat(roadSizeInput.value);
                renderRoadNetwork();
                calculateRoadFollowingStats(); // Recalculate with new scale
                renderTrajectories(0);
                debugLog("Applied road size", { scale: roadMapScale });
            });
            
            // Debug toggle
            document.getElementById('debug-toggle').addEventListener('change', (e) => {
                const debugConsole = document.querySelector('.debug-console');
                debugConsole.style.display = e.target.checked ? 'block' : 'none';
                if (e.target.checked) {
                    debugLog("Debug mode enabled");
                }
            });
            
            debugLog("Initialization complete");
        }
        
        // Make sure all functions are available globally
        window.renderTrajectories = renderTrajectories;
        window.generateTrajectories = generateTrajectories;
        window.generateVehicles = generateVehicles;
        window.renderVehicles = renderVehicles;
        window.initVisualization = initialize;
        window.currentTrajectoryData = currentTrajectoryData;
        window.currentVehicleData = currentVehicleData;
        window.config = {
            animationDuration: 20000, // 20 seconds for animation
            objectColors: config.objectColors
        };
        
        // Initialize when the DOM is fully loaded
        window.addEventListener('DOMContentLoaded', function() {
            // First initialize our visualization
            initialize();
            
            // Make sure all buttons have proper z-index and are clickable
            document.querySelectorAll('button').forEach(function(button) {
                button.style.position = 'relative';
                button.style.zIndex = '10';
            });
        });
    </script>
</body>
</html>
